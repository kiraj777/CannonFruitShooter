<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Cannon Fruit Shooter</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f0f0f0;
            margin: 0;
            padding: 0;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            touch-action: manipulation;
        }
        #game-container {
            text-align: center;
            width: 100%;
            height: 100%;
        }
        #canvas {
            width: 100vw;
            height: calc(100vw * 428 / 926); /* Maintain 2778:1284 aspect ratio */
            max-height: 100vh;
            border: 2px solid #333;
            background-color: #d3d3d3;
            touch-action: manipulation;
        }
        #status {
            margin: 5px 0;
            font-size: 14px;
            width: 90%;
        }
        #controls {
            margin-bottom: 5px;
        }
        button {
            padding: 5px 10px;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="controls">
            <button onclick="startGame()" tabindex="-1">New Game</button>
        </div>
        <div id="status">Level: 1 | Score: 0 | Lives: 2 | Status: Touch to move/shoot, tap to resume levels</div>
        <canvas id="canvas"></canvas>
    </div>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let cannon, balls, fruits, score, fruitsMissed, gameState, lastSpawnTime, baseFruitSpeed, speedMultiplier, level, heartsSpawned, specialSpawned, lives;
        const initialBaseSpeed = 0.6;
        const fruitTypes = [
            { type: 'grapes', emoji: 'üçá', points: 40, radius: 20, isHeart: false, isSpecial: false },
            { type: 'apple', emoji: 'üçé', points: 30, radius: 18, isHeart: false, isSpecial: false },
            { type: 'strawberry', emoji: 'üçì', points: 20, radius: 15, isHeart: false, isSpecial: false },
            { type: 'cherry', emoji: 'üçí', points: 10, radius: 12, isHeart: false, isSpecial: false },
            { type: 'heart', emoji: '‚ù§Ô∏è', points: 0, radius: 15, isHeart: true, isSpecial: false },
            { type: 'mango', emoji: 'ü•≠', points: 200, radius: 40, isHeart: false, isSpecial: true }
        ];
        const veggieTypes = [
            { type: 'onion', emoji: 'üßÖ', points: 40, radius: 20, isHeart: false, isSpecial: false },
            { type: 'tomato', emoji: 'üçÖ', points: 30, radius: 18, isHeart: false, isSpecial: false },
            { type: 'potato', emoji: 'ü•î', points: 20, radius: 15, isHeart: false, isSpecial: false },
            { type: 'cucumber', emoji: 'ü•í', points: 10, radius: 12, isHeart: false, isSpecial: false },
            { type: 'heart', emoji: '‚ù§Ô∏è', points: 0, radius: 15, isHeart: true, isSpecial: false },
            { type: 'carrot', emoji: 'ü•ï', points: 200, radius: 40, isHeart: false, isSpecial: true }
        ];
        const clouds = [];
        let touchX = null;
        let canvasWidth = 926; // Logical width for iPhone 13 Pro Max
        let canvasHeight = 428; // Logical height for iPhone 13 Pro Max

        function resizeCanvas() {
            canvas.width = canvasWidth * window.devicePixelRatio;
            canvas.height = canvasHeight * window.devicePixelRatio;
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
        }

        function initClouds() {
            clouds.length = 0;
            for (let i = 0; i < 5; i++) {
                clouds.push({
                    x: Math.random() * canvasWidth,
                    y: Math.random() * (canvasHeight - 100),
                    radiusX: 15 + Math.random() * 25,
                    radiusY: 10 + Math.random() * 15,
                    opacity: 0.5 + Math.random() * 0.3
                });
            }
        }

        function startAudio() {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            gainNode = audioContext.createGain();
            gainNode.gain.value = 0.1;
            gainNode.connect(audioContext.destination);

            const notes = [261.63, 329.63, 392.00, 440.00];
            let noteIndex = 0;

            function playNextNote() {
                if (gameState !== 'playing') return;
                oscillator = audioContext.createOscillator();
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(notes[noteIndex], audioContext.currentTime);
                oscillator.connect(gainNode);
                oscillator.start();
                oscillator.stop(audioContext.currentTime + 0.5);
                noteIndex = (noteIndex + 1) % notes.length;
                setTimeout(playNextNote, 500);
            }

            playNextNote();
        }

        function stopAudio() {
            if (audioContext) {
                audioContext.close();
                audioContext = null;
            }
        }

        function startGame() {
            cannon = { x: canvasWidth / 2, y: canvasHeight - 30, width: 40, height: 20, speed: 5 };
            balls = [];
            fruits = [];
            score = 0;
            fruitsMissed = 0;
            gameState = 'playing';
            lastSpawnTime = Date.now();
            baseFruitSpeed = initialBaseSpeed;
            speedMultiplier = 1.0;
            level = 1;
            heartsSpawned = 0;
            specialSpawned = false;
            lives = 2; // Starting lives
            touchX = null;
            initClouds();
            startAudio();
            document.getElementById('status').textContent = `Level: ${level} | Score: ${score} | Lives: ${lives} | Status: Touch to move/shoot, tap to resume levels`;
            resizeCanvas();
            gameLoop();
        }

        function spawnFruit() {
            const currentLevel = Math.floor(score / 1000) + 1;
            let availableTypes = fruitTypes.filter(f => !f.isHeart && !f.isSpecial);
            if (heartsSpawned < 2 && Math.random() < 0.05) {
                availableTypes = fruitTypes.filter(f => f.isHeart);
            } else if (currentLevel >= 2 && !specialSpawned && Math.random() < 0.05) {
                availableTypes = fruitTypes.filter(f => f.isSpecial);
            }
            if (currentLevel >= 3) {
                availableTypes = veggieTypes.filter(f => !f.isHeart && !f.isSpecial);
                if (heartsSpawned < 2 && Math.random() < 0.05) {
                    availableTypes = veggieTypes.filter(f => f.isHeart);
                } else if (currentLevel >= 2 && !specialSpawned && Math.random() < 0.05) {
                    availableTypes = veggieTypes.filter(f => f.isSpecial);
                }
            }
            const fruit = availableTypes[Math.floor(Math.random() * availableTypes.length)];
            fruits.push({
                x: Math.random() * (canvasWidth - 40) + 20,
                y: 0,
                type: fruit.type,
                emoji: fruit.emoji,
                points: fruit.points,
                radius: fruit.radius,
                speed: baseFruitSpeed * speedMultiplier,
                isHeart: fruit.isHeart,
                isSpecial: fruit.isSpecial
            });
            if (fruit.isHeart) heartsSpawned++;
            if (fruit.isSpecial) specialSpawned = true;
        }

        function draw() {
            ctx.clearRect(0, 0, canvasWidth, canvasHeight);

            // Define gradient based on level
            let topColor, bottomColor;
            switch (level) {
                case 1:
                    topColor = `hsl(210, 10%, 90%)`; // Soft blue-gray
                    bottomColor = `hsl(210, 5%, 85%)`;
                    break;
                case 2:
                    topColor = `hsl(150, 10%, 85%)`; // Pale green
                    bottomColor = `hsl(150, 5%, 80%)`;
                    break;
                case 3:
                    topColor = `hsl(270, 10%, 85%)`; // Light purple-gray
                    bottomColor = `hsl(270, 5%, 80%)`;
                    break;
                default:
                    topColor = `hsl(300, 10%, 85%)`; // Soft lavender
                    bottomColor = `hsl(300, 5%, 80%)`;
            }

            const gradient = ctx.createLinearGradient(0, 0, 0, canvasHeight);
            gradient.addColorStop(0, topColor);
            gradient.addColorStop(1, bottomColor);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);

            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            clouds.forEach(cloud => {
                ctx.beginPath();
                ctx.ellipse(cloud.x, cloud.y, cloud.radiusX, cloud.radiusY, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.closePath();
            });

            if (gameState === 'paused') {
                ctx.fillStyle = 'black';
                ctx.font = '24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`Level ${level}`, canvasWidth / 2, canvasHeight / 2);
                ctx.font = '16px Arial';
                ctx.fillText('Tap to Continue', canvasWidth / 2, canvasHeight / 2 + 30);
                return;
            }

            if (gameState === 'over') {
                ctx.fillStyle = 'black';
                ctx.font = '40px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Game Over', canvasWidth / 2, canvasHeight / 2 - 20);
                ctx.font = '30px Arial';
                ctx.fillText(`Final Score: ${score}`, canvasWidth / 2, canvasHeight / 2 + 20);
                return;
            }

            ctx.fillStyle = '#555';
            ctx.fillRect(cannon.x - cannon.width / 2, cannon.y - cannon.height, cannon.width, cannon.height);

            ctx.fillStyle = '#555';
            ctx.beginPath();
            ctx.fillRect(cannon.x - 5, cannon.y - cannon.height - 20, 10, 20);
            ctx.closePath();

            ctx.fillStyle = 'black';
            balls.forEach(ball => {
                ctx.beginPath();
                ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.closePath();
            });

            ctx.textAlign = 'left';
            fruits.forEach(fruit => {
                ctx.font = `${fruit.radius * 2}px Arial`;
                if (fruit.isSpecial) {
                    ctx.fillStyle = '#ffd700';
                } else {
                    ctx.fillStyle = 'black';
                }
                ctx.fillText(fruit.emoji, fruit.x - fruit.radius, fruit.y + fruit.radius / 2);
            });
        }

        function update() {
            const currentLevel = Math.floor(score / 1000) + 1;
            if (currentLevel > level && gameState === 'playing') {
                level = currentLevel;
                if (lives < 4) lives += 1; // Add extra life only if under 4
                gameState = 'paused';
                if (level === 2) {
                    baseFruitSpeed = initialBaseSpeed * 1.2;
                } else if (level >= 3) {
                    baseFruitSpeed *= 1.1;
                }
                heartsSpawned = 0;
                specialSpawned = false;
                document.getElementById('status').textContent = `Level: ${level} | Score: ${score} | Lives: ${lives} | Status: Tap to start`;
                return;
            }

            if (gameState !== 'playing') return;

            speedMultiplier = 1.0 + Math.floor(score / 100) * 0.1;

            if (touchX !== null) {
                let newX = touchX * (canvasWidth / canvas.offsetWidth);
                if (newX < cannon.width / 2) newX = cannon.width / 2;
                if (newX > canvasWidth - cannon.width / 2) newX = canvasWidth - cannon.width / 2;
                cannon.x = newX;
            }

            balls = balls.filter(ball => ball.y > 0);
            balls.forEach(ball => {
                ball.y -= ball.speed;
            });

            fruits = fruits.filter(fruit => fruit.y < canvasHeight);
            fruits.forEach(fruit => {
                fruit.y += fruit.speed;
                if (fruit.y + fruit.radius >= canvasHeight) {
                    if (!fruit.isHeart) {
                        lives -= 1; // Decrease lives on miss
                        if (lives <= 0) {
                            gameState = 'over';
                            stopAudio();
                        } else {
                            document.getElementById('status').textContent = `Level: ${level} | Score: ${score} | Lives: ${lives} | Status: Touch to move/shoot, tap to resume levels`;
                        }
                    }
                    fruits = fruits.filter(f => f !== fruit);
                }
            });

            balls.forEach(ball => {
                fruits = fruits.filter(fruit => {
                    const dx = ball.x - fruit.x;
                    const dy = ball.y - fruit.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance < ball.radius + fruit.radius) {
                        if (fruit.isHeart) {
                            lives = Math.min(4, lives + 1); // Increase life by 1 when heart is hit, cap at 4
                            document.getElementById('status').textContent = `Level: ${level} | Score: ${score} | Lives: ${lives} | Status: Touch to move/shoot, tap to resume levels`;
                        } else {
                            score += fruit.points; // Increment score immediately
                            document.getElementById('status').textContent = `Level: ${level} | Score: ${score} | Lives: ${lives} | Status: Touch to move/shoot, tap to resume levels`;
                        }
                        return false;
                    }
                    return true;
                });
            });

            if (Date.now() - lastSpawnTime > (1000 + Math.random() * 1000) && gameState === 'playing') {
                spawnFruit();
                lastSpawnTime = Date.now();
            }
        }

        let keys = {};
        canvas.addEventListener('touchmove', (event) => {
            event.preventDefault();
            const touch = event.touches[0];
            if (touch.clientY > canvas.height - 100) {
                touchX = touch.clientX;
            }
        });

        canvas.addEventListener('touchstart', (event) => {
            event.preventDefault();
            if (gameState === 'paused') {
                gameState = 'playing';
                startAudio();
                document.getElementById('status').textContent = `Level: ${level} | Score: ${score} | Lives: ${lives} | Status: Touch to move/shoot, tap to resume levels`;
            } else if (gameState === 'playing') {
                balls.push({ x: cannon.x, y: cannon.y - cannon.height - 20, radius: 5, speed: 10 });
            }
        });

        canvas.addEventListener('touchend', () => {
            touchX = null;
        });

        document.addEventListener('keydown', (event) => {
            if (gameState === 'paused' && (event.key === ' ' || event.key === 'ArrowLeft' || event.key === 'ArrowRight')) {
                gameState = 'playing';
                startAudio();
                document.getElementById('status').textContent = `Level: ${level} | Score: ${score} | Lives: ${lives} | Status: Touch to move/shoot, tap to resume levels`;
            }
            if (event.key === ' ' && gameState === 'playing') {
                event.preventDefault();
                balls.push({ x: cannon.x, y: cannon.y - cannon.height - 20, radius: 5, speed: 10 });
            }
            keys[event.key] = true;
        });

        document.addEventListener('keyup', (event) => {
            keys[event.key] = false;
        });

        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        startGame();
        window.addEventListener('resize', resizeCanvas);
    </script>
</body>
</html>